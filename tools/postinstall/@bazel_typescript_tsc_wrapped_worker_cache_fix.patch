diff --git node_modules/@bazel/typescript/internal/tsc_wrapped/compiler_host.js node_modules/@bazel/typescript/internal/tsc_wrapped/compiler_host.js
index 031d9dad1..b9df57eb4 100644
--- node_modules/@bazel/typescript/internal/tsc_wrapped/compiler_host.js
+++ node_modules/@bazel/typescript/internal/tsc_wrapped/compiler_host.js
@@ -38,6 +38,44 @@ function validateBazelOptions(bazelOpts) {
     }
 }
 const SOURCE_EXT = /((\.d)?\.tsx?|\.js)$/;
+
+/** Name of the TypeScript source file property containing the module name. */
+const MODULE_NAME_PROP = 'moduleName';
+
+/**
+ * Updates the given source file with a specified module name at constant time. The module name
+ * is not directly assigned to the source file object, but exposed through a proxy handler that
+ * wraps the source file. This ensures that changing the `moduleName` does not affect the original
+ * source file which originates from a cache and should not be invalidated.
+ */
+function wrapSourceFileWithModuleName(sourceFile, moduleName) {
+  return new Proxy(sourceFile, {
+    has: (target, prop) => prop === MODULE_NAME_PROP || Reflect.has(target, prop),
+    ownKeys: (target) => Reflect.ownKeys(target).concat(MODULE_NAME_PROP),
+    getOwnPropertyDescriptor: (target, prop) => {
+      if (prop === MODULE_NAME_PROP) {
+        // TypeScript sometimes will enumerate through top-level properties of
+        // a source file (e.g. to create a mutable clone). The module name should
+        // not be skipped by accident here.
+        return {configurable: true, enumerable: true};
+      }
+      return Reflect.getOwnPropertyDescriptor(target, prop);
+    },
+    get: function(target, prop, receiver) {
+      if (prop === MODULE_NAME_PROP) {
+        return moduleName;
+      }
+      return Reflect.get(target, prop, receiver);
+    },
+    set: function(target, prop, value, receiver) {
+      if (prop === MODULE_NAME_PROP) {
+        return false;
+      }
+      return Reflect.set(target, prop, value, receiver);
+    },
+  })
+}
+
 /**
  * CompilerHost that knows how to cache parsed files to improve compile times.
  */
@@ -377,9 +415,11 @@ class CompilerHost {
                         `which would be overwritten with ${moduleName} ` +
                         `by Bazel's TypeScript compiler.`);
                 }
-                // Setting the moduleName is equivalent to the original source having a
-                // ///<amd-module name="some/name"/> directive
-                sf.moduleName = moduleName;
+                // Setting the moduleName is equivalent to the original source having the triple
+                // slash `///<amd-module name="some/name"/>` directive. Also note that we do not
+                // directly modify the source file `moduleName` property as that means that
+                // consecutive compilations using a cache could have an unexpected module name.
+                return wrapSourceFileWithModuleName(sf, moduleName);
             }
             return sf;
         });
